#pragma kernel CSMain

// Simplex Noise implementation adapted from Stefan Gustavson's implementation:
// https://github.com/stegu/webgl-noise/blob/master/src/simplex3d.glsl

RWTexture2D<float4> Result;
int _Resolution;
float _Scale;
float2 _Offset;

#define FASTFLOOR(x) (floor(x))

float2 mod289(float2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float3 mod289(float3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float3 permute(float3 x) { return mod289(((x*34.0)+1.0)*x); }
float3 taylorInvSqrt(float3 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float3 fade(float3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }


// Simplex noise
float snoise(float2 v) {
    const float2 C = float2(0.21132486540518713, 0.3660254037844386); // (1.0/sqrt(3.0), 2.0/sqrt(3.0))
    float2 i = floor(v + dot(v, C.yy));
    float2 x0 = v - i + dot(i, C.xx);
    float2 i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float4 x12 = float4(x0.x, x0.y, x0.x, x0.y) + float4(C.x, C.x, C.y, C.y);
    x12.xy -= i1;
    i = mod289(i); // Permutations
    float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0)) + i.x + float3(0.0, i1.x, 1.0));
    float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    float3 x = 2.0 * frac(p * (1.0 / 41.0)) - 1.0;
    float3 h = abs(x) - 0.5;
    float3 ox = floor(x + 0.5);
    float3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    float3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Calculate UV coordinates in the range [0, 1]
    float2 uv = float2(id.xy) / float2(_Resolution, _Resolution);

    // Calculate simplex noise value
    float noiseValue = snoise(uv * _Scale + _Offset);

    // Write noise value to the result texture
    Result[id.xy] = float4(noiseValue, noiseValue, noiseValue, 1.0);
}
